import "./chunk-OL46QLBJ.js";

// node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/defs.mjs
function splitSVGDefs(content, tag = "defs") {
  let defs = "";
  const index = content.indexOf("<" + tag);
  while (index >= 0) {
    const start = content.indexOf(">", index);
    const end = content.indexOf("</" + tag);
    if (start === -1 || end === -1) {
      break;
    }
    const endEnd = content.indexOf(">", end);
    if (endEnd === -1) {
      break;
    }
    defs += content.slice(start + 1, end).trim();
    content = content.slice(0, index).trim() + content.slice(endEnd + 1);
  }
  return {
    defs,
    content
  };
}
function mergeDefsAndContent(defs, content) {
  return defs ? "<defs>" + defs + "</defs>" + content : content;
}
function wrapSVGContent(body, start, end) {
  const split = splitSVGDefs(body);
  return mergeDefsAndContent(split.defs, start + split.content + end);
}

// node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/viewbox.mjs
function getSVGViewBox(value) {
  const result = value.trim().split(/\s+/).map(Number);
  if (result.length === 4 && result.reduce((prev, value2) => prev && !isNaN(value2), true)) {
    return result;
  }
}

// node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/parse.mjs
function parseSVGContent(content) {
  const match = content.trim().match(
    /(?:<(?:\?xml|!DOCTYPE)[^>]+>\s*)*<svg([^>]+)>([\s\S]+)<\/svg[^>]*>/
  );
  if (!match) {
    return;
  }
  const body = match[2].trim();
  const attribsList = match[1].match(/[\w:-]+="[^"]*"/g);
  const attribs = /* @__PURE__ */ Object.create(null);
  attribsList == null ? void 0 : attribsList.forEach((row) => {
    const match2 = row.match(/([\w:-]+)="([^"]*)"/);
    if (match2) {
      attribs[match2[1]] = match2[2];
    }
  });
  return {
    attribs,
    body
  };
}
function build(data) {
  const attribs = data.attribs;
  const viewBox = getSVGViewBox(attribs["viewBox"] ?? "");
  if (!viewBox) {
    return;
  }
  const groupAttributes = [];
  for (const key in attribs) {
    if (key === "style" || key.startsWith("fill") || key.startsWith("stroke")) {
      groupAttributes.push(`${key}="${attribs[key]}"`);
    }
  }
  let body = data.body;
  if (groupAttributes.length) {
    body = wrapSVGContent(
      body,
      "<g " + groupAttributes.join(" ") + ">",
      "</g>"
    );
  }
  return {
    // Copy dimensions if exist
    width: attribs.width,
    height: attribs.height,
    viewBox,
    body
  };
}
function buildParsedSVG(data) {
  const result = build(data);
  if (result) {
    return {
      attributes: {
        // Copy dimensions if exist
        width: result.width,
        height: result.height,
        // Merge viewBox
        viewBox: result.viewBox.join(" ")
      },
      viewBox: result.viewBox,
      body: result.body
    };
  }
}
function convertParsedSVG(data) {
  const result = build(data);
  if (result) {
    const viewBox = result.viewBox;
    return {
      left: viewBox[0],
      top: viewBox[1],
      width: viewBox[2],
      height: viewBox[3],
      body: result.body
    };
  }
}
export {
  buildParsedSVG,
  convertParsedSVG,
  parseSVGContent
};
//# sourceMappingURL=@iconify_utils_lib_svg_parse.js.map
